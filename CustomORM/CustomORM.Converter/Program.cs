using CustomORM.Converter.Extensions;
using Microsoft.CodeAnalysis;
using System.Text;

namespace CustomORM.Converter;

internal static class Program
{
    static void Main(string[] args)
    {
        if (args.Length < 2 || args.Length > 3)
            throw new ArgumentException("Check args");

        string folderSource = args[0];
        string folderTarget = args[1];
        string namespaceTarget = args.Length < 3 ? string.Empty : args[2];

        if (!Directory.Exists(folderSource))
            throw new ArgumentException("Folder source not found");

        if (!Directory.Exists(folderTarget))
            throw new ArgumentException("Folder target not found");

        // Find hubs
        var dv2FilesHubs = Directory.GetFiles(folderSource, "H*", SearchOption.TopDirectoryOnly);

        foreach (var dv2HubFile in dv2FilesHubs)
        {
            var hubName = Path.GetFileNameWithoutExtension(dv2HubFile);

            // Find View for current hub
            var dv2ViewFile = Path.Combine(folderSource, $"V{hubName[1..]}.cs");
            if (!Path.Exists(dv2ViewFile))
                throw new Exception($"View entity {$"V{hubName[1..]}.cs"} not found");

            // Get class content
            var contentEntityClass = BuildContentRelationalEntity(dv2HubFile, dv2ViewFile, hubName[1..], namespaceTarget);

            // check class
            using (var peStream = new MemoryStream())
            {
                var result = contentEntityClass
                    .CompileAssembly()
                    .Emit(peStream);

                if (!result.Success)
                {
                    Console.WriteLine("Error on compilation.");

                    var failures = result.Diagnostics.Where(diagnostic => diagnostic.IsWarningAsError || diagnostic.Severity == DiagnosticSeverity.Error);
                    failures.LogDiagnostics();
                }
                else
                {
                    peStream.Seek(0, SeekOrigin.Begin);

                    // save file (new class <=> relational entity)
                    File.WriteAllText(Path.Combine(folderTarget, $"{hubName[1..]}.cs"), contentEntityClass);
                    // info
                    Console.WriteLine($"File {hubName[1..]}.cs generated");
                }
            }
        }

        Console.WriteLine("Press key to close");
        Console.ReadLine();
    }

    private static string BuildContentRelationalEntity(string hubPath, string viewPath, string entityName, string namespaceTarget)
    {
        StringBuilder sb = new StringBuilder();

        var hubLines = File.ReadLines(hubPath);
        var viewLines = File.ReadLines(viewPath);
        var hubProperties = PropertiesExtractor.GetProperties(hubLines);
        var viewProperties = PropertiesExtractor.GetProperties(viewLines);
        var functionalKeyProperty = PropertiesExtractor.GetFunctionnalKeyProperty(hubProperties, viewProperties);
        var annotationKeyProperty = PropertiesExtractor.GetAnnotation(functionalKeyProperty, viewLines);

        sb.AppendLine("// <auto-generated> This file has been auto generated by CustomORM.Converter. </auto-generated>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.ComponentModel.DataAnnotations;");
        sb.AppendLine();
        if (namespaceTarget.Length > 0)
        {
            sb.AppendLine($"namespace {namespaceTarget};");
            sb.AppendLine();
        }
        sb.AppendLine($"public sealed class {entityName}");
        sb.AppendLine("{");
        sb.AppendIndentedLine("[Key]");
        if (annotationKeyProperty != null)
            sb.AppendIndentedLine(annotationKeyProperty);
        sb.AppendIndentedLine(functionalKeyProperty);
        sb.AppendLine();

        var noFunctionnalKeyProperties = PropertiesExtractor.GetNoFunctionnalKeyProperties(hubProperties, viewProperties);

        foreach (var (property, index) in noFunctionnalKeyProperties.WithIndex())
        {
            var annotationProperty = PropertiesExtractor.GetAnnotation(property, viewLines);
            if (annotationProperty != null)
                sb.AppendIndentedLine(annotationProperty);
            sb.AppendIndentedLine(property);

            if (index != noFunctionnalKeyProperties.Count - 1)
                sb.AppendLine();
        }

        sb.AppendLine("}");

        return sb.ToString();
    }
}
